<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>包装类</title>
      <link href="/2022/0628undefined.html"/>
      <url>/2022/0628undefined.html</url>
      
        <content type="html"><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>Java有八种基本类型，每种基本类型都有一个对应的包装类。 </p><p>Java中，基本类型和对应的包装类如下表所示：</p><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table><p>包装类也都很好记，除了Integer和Character外，其他类名称与基本类型基本一样，只是首字母大写。</p><h3 id="基本类型和包装类"><a href="#基本类型和包装类" class="headerlink" title="基本类型和包装类"></a><strong>基本类型和包装类</strong></h3><p><strong>Boolean</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">boolean b1 &#x3D; false;Boolean bObj &#x3D; Boolean.valueOf(b1);boolean b2 &#x3D; bObj.booleanValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Byte</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">byte b1 &#x3D; 123;Byte byteObj &#x3D; Byte.valueOf(b1);byte b2 &#x3D; byteObj.byteValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Short</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">short s1 &#x3D; 12345;Short sObj &#x3D; Short.valueOf(s1);short s2 &#x3D; sObj.shortValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Integer</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int i1 &#x3D; 12345;Integer iObj &#x3D; Integer.valueOf(i1);int i2 &#x3D; iObj.intValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Long</strong>Java</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">long l1 &#x3D; 12345;Long lObj &#x3D; Long.valueOf(l1);long l2 &#x3D; lObj.longValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Float</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">float f1 &#x3D; 123.45f;Float fObj &#x3D; Float.valueOf(f1);float f2 &#x3D; fObj.floatValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Double</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">double d1 &#x3D; 123.45;Double dObj &#x3D; Double.valueOf(d1);double d2 &#x3D; dObj.doubleValue(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Character</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">char c1 &#x3D; &#39;A&#39;;Character cObj &#x3D; Character.valueOf(c1);char c2 &#x3D; cObj.charValue(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Java1-5后的技术"><a href="#Java1-5后的技术" class="headerlink" title="Java1.5后的技术"></a>Java1.5后的技术</h3><p>java 1.5以后引入了自动装箱和拆箱技术，可以直接将基本类型赋值给引用类型，反之亦可，如下代码所示：</p><pre class="line-numbers language-none"><code class="language-none">Integer a &#x3D; 100;int b &#x3D; a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>自动装箱/拆箱是Java编译器提供的能力，背后，它会替换为调用对应的valueOf()/xxxValue()，比如说，上面的代码会被Java编译器替换为：</p><pre class="line-numbers language-none"><code class="language-none">Integer a &#x3D; Integer.valueOf(100);int b &#x3D; a.intValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>每种包装类也都有构造方法，可以通过new创建，比如说：</p><pre class="line-numbers language-none"><code class="language-none">Integer a &#x3D; new Integer(100);Boolean b &#x3D; new Boolean(true);Double d &#x3D; new Double(12.345);Character c &#x3D; new Character(&#39;马&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所有的包装类都重写了Object类</p><p>在equals中是用于判断当前对象和参数传入的对象是否相同，Object类的默认实现是比较地址，</p><p>Float有一个静态方法floatToIntBits()，将float的二进制表示看做int。需要注意的是，只有两个float的二进制表示完全一样的时候，equals才会返回true。 </p><p>Double的equals方法与Float类似，它有一个静态方法doubleToLongBits，将double的二进制表示看做long，然后再按long比较。 </p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>包装类都重写了hashCode，根据包装的基本类型值计算hashCode，对于Byte, Short, Integer, Character，hashCode就是其内部值 </p><p>hashCode 返回一个对象的哈希值，哈希值是一个int类型的数，由对象中一般不变的属性映射得来，用于快速对对象进行区分、分组等。一个对象的哈希值不能变，相同对象的哈希值必须一样。 不同对象的哈希值一般应不同，但这不是必须的，可以有不同对象但哈希值相同的情况。 </p><p>hashCode和equals方法联系密切，对两个对象，如果equals方法返回true，则hashCode也必须一样。反之不要求，equal返回false时，hashCode可以一样，也可以不一样，但应该尽量不一样。hashCode的默认实现一般是将对象的内存地址转换为整数，子类重写equals时，也必须重写hashCode。之所以有这个规定，是因为Java API中很多类依赖于这个行为，尤其是集合中的一些类。</p><p>  1.如果两个对象相同，那么它们的hashCode值一定要相同；<br>  2.如果两个对象的hashCode相同，它们并不一定相同<br>  （这里说的对象相同指的是用eqauls方法比较）。<br>    如不按要求去做了，会发现相同的对象可以出现在Set集合中，<br>    同时，增加新元素的效率会大大下降。<br>  3.equals()相等的两个对象，hashcode()一定相等；<br>  equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>包装类都重写了hashCode，根据包装的基本类型值计算hashCode，对于Byte, Short, Integer, Character，hashCode就是其内部值， </p><p><strong>Comparable</strong></p><p>每个包装类也都实现了Java API中的Comparable接口，Comparable接口代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public interface Comparable&lt;T&gt; &#123;    public int compareTo(T o);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="包装类和String"><a href="#包装类和String" class="headerlink" title="包装类和String"></a><strong>包装类和String</strong></h3><p>除了toString方法外，包装类还有一些其他与String相关的方法。</p><p>除了Character外，每个包装类都有一个静态的valueOf(String)方法，根据字符串表示返回包装类对象，如：</p><pre class="line-numbers language-none"><code class="language-none">Boolean b &#x3D; Boolean.valueOf(&quot;true&quot;);Float f &#x3D; Float.valueOf(&quot;123.45f&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也都有一个静态的parseXXX(String)方法，根据字符串表示返回基本类型值，如：</p><pre class="line-numbers language-none"><code class="language-none">boolean b &#x3D; Boolean.parseBoolean(&quot;true&quot;);double d &#x3D; Double.parseDouble(&quot;123.45&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>都有一个静态的toString()方法，根据基本类型值返回字符串表示，如：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">System.out.println(Boolean.toString(true));System.out.println(Double.toString(123.45));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="常用常量"><a href="#常用常量" class="headerlink" title="常用常量"></a><strong>常用常量</strong></h3><p>包装类中除了定义静态方法和实例方法外，还定义了一些静态变量。</p><p>Boolean类型：</p><pre class="line-numbers language-none"><code class="language-none">public static final Boolean TRUE &#x3D; new Boolean(true);public static final Boolean FALSE &#x3D; new Boolean(false);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>所有数值类型都定义了MAX_VALUE和MIN_VALUE，表示能表示的最大/最小值，比如，对Integer：</p><pre class="line-numbers language-none"><code class="language-none">public static final int   MIN_VALUE &#x3D; 0x80000000;public static final int   MAX_VALUE &#x3D; 0x7fffffff;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Float和Double还定义了一些特殊数值，比如正无穷、负无穷、非数值，如Double类：</p><pre class="line-numbers language-none"><code class="language-none">public static final double POSITIVE_INFINITY &#x3D; 1.0 &#x2F; 0.0;public static final double NEGATIVE_INFINITY &#x3D; -1.0 &#x2F; 0.0;public static final double NaN &#x3D; 0.0d &#x2F; 0.0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a><strong>Number</strong></h3><p>六种数值类型包装类有一个共同的父类Number，Number是一个抽象类，它定义了如下方法：</p><pre class="line-numbers language-none"><code class="language-none">byte byteValue()short shortValue()                int intValue()long longValue()float floatValue()double doubleValue()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以返回任意的基本数值类型。</p><h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性**"></a>不可变性**</h3><p>包装类都是不可变类，所谓不可变就是，实例对象一旦创建，就没有办法修改了。这是通过如下方式强制实现的：</p><ul><li>所有包装类都声明为了final，不能被继承</li><li>内部基本类型值是私有的，且声明为了final</li><li>没有定义setter方法</li></ul><p>为什么要定义为不可变类呢？不可变使得程序可以更为简单安全，因为不用操心数据被意外改写的可能了，可以安全的共享数据，尤其是在多线程的环境下</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础</title>
      <link href="/2022/0405undefined.html"/>
      <url>/2022/0405undefined.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql基础"><a href="#Mysql基础" class="headerlink" title="Mysql基础"></a>Mysql基础</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>数据库分为关系型数据库和非关系型数据库（重点学习redis）</p><p>MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p><p>DB : DataBase 数据库    DBMS  :  数据库管理系统    SQL ： 一种语言<br>然而DBMS负责执行SQL语句同时来操作DB当中的数据</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>DQL  （数据查询）查询语句  凡是select语句都是DQL<br>DML  （数据操作）insert  delete update 对表的中的数据进行增加删改<br>DDL  （数据定义）create drop alter 对表的结构进行增删改<br>TCL   （事务控制）commit 提交事务 roolllback 回滚事务<br>DCL （数据控制）  grant授权  revoke撤销权限等</p><h2 id="数据库的使用"><a href="#数据库的使用" class="headerlink" title="数据库的使用"></a>数据库的使用</h2><ol><li><p>数据库的<a href="https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&tn=baidu&wd=mysql%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&oq=Mysql%25E7%2599%25BE%25E5%25BA%25A6&rsv_pq=90b15b6400007c81&rsv_t=fe50btkb/o8H2zA0LfT7nf10BPalL86LKP6n6nqCHCF9sw0JuoKqH6nxri8&rqlang=cn&rsv_dl=ts_0&rsv_enter=1&rsv_btype=t&inputT=2466&rsv_sug3=14&rsv_sug1=11&rsv_sug7=100&rsv_sug2=1&prefixsug=Mysql&rsp=0&rsv_sug4=2890">安装</a></p></li><li><p>数据库的基本使用</p><p>查看数据 show databases;</p><p>创建数据库 create database huihui;</p><p>使用数据库 user huihui;  show tables;</p><p>删除数据库 drop database 数据库；</p></li><li><p>步骤</p><p>一、登录 打开dos命令窗口</p><p>​        mysql -uroot -p(密码是隐藏的)</p><p>二、查看有那些数据库  </p><p>​        show databases; </p><p>三、创建数据库</p><p>​        create database huihui;</p><p>四、使用数据库</p><p>​        show tables;</p><p>五、查看当前使用的数据</p><p>​        show tables;<br>六、创建一个表的结构<br>​        create table category(cid varchar(20) primary key,cname varchar(100));<br>​        </p><p>七、其他基本操作</p><p>​        查看表结构<br>​            desc category;<br>​        删除表的结构<br>​            drop tables;<br>​        删除库<br>​            drop detabase;<br>​        查看现在使用哪个数据库<br>​            select database();<br>​        修改表添加列<br>​            alter table 表名 add <code>列名</code> 类型（长度）约束；使用反引号<br>​        修改表的列名<br>​            alter table change 旧列名 新列名 类型（长度）；<br>​        修改表删除列<br>​            alter table 表名 drop 列名；<br>​        修改表的名字<br>​            rename table  表名 to 新表名；</p></li></ol><p>​        八、插入表记录</p><p>​            insert into 表（字段1 ，字段2，字段3）values(值1 值2 值3)；</p><p>​            insert into 表 value（值1 ，值2 ，值3）</p><p>​        九、更新记录</p><p>​            update 表名 set 字段名 = 值 ， 字段名 = 值；</p><pre><code>       update  category set cname = &#39;家电&#39;；  将所有行cname改为家电          update category set  cname = &#39;水果&#39; where cid = &#39;coo1&#39; 将c001改为水果</code></pre><p>​        十、删除表格</p><p>​            delete from category;</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>表格前期的准备</p><p> create table product(<br> pid int primary key,<br> pname varchar(20),<br> price double,<br> category_id varchar(32)<br> );</p><p> insert into product(pid,pname,price,category_id) values(1,’联想’,5000,’c001’);<br> insert into product(pid,pname,price,category_id) values(2,’海尔’,3000,’c001’);<br> insert into product(pid,pname,price,category_id) values(3,’雷神’,5000,’c001’);<br> insert into product(pid,pname,price,category_id) values(4,’杰克琼斯’,800,’c002’);<br> insert into product(pid,pname,price,category_id) values(5,’真维斯’,200,’c002’);<br> insert into product(pid,pname,price,category_id) values(6,’花花公子’,440,’c002’);<br> insert into product(pid,pname,price,category_id) values(7,’劲霸’,2000,’c002’);<br> insert into product(pid,pname,price,category_id) values(8,’香奈儿’,800,’c003’);<br> insert into product(pid,pname,price,category_id) values(9,’相一本草’,200,’c003’);<br> insert into product(pid,pname,price,category_id) values(10,’面霸’,5,’c003’);<br> insert into product(pid,pname,price,category_id) values(11,’好想你枣’,56,’c004’);<br> insert into product(pid,pname,price,category_id) values(12,’香飘飘奶茶’,2,’c005’);<br> insert into product(pid,pname,price,category_id) values(13,’海澜之家’,1,’c002’);<br> insert into product(pid,pname,price,category_id) values(14,’辉辉’,5000,’c005’);</p><p> select pname,price from product;  查询价格和产品名称<br>+————+——-+</p><table><thead><tr><th>pname</th><th>price</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>+————+——-+</td><td></td></tr><tr><td>联想</td><td>5000</td></tr><tr><td>—-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>海尔</td><td>3000</td></tr><tr><td>—-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>雷神</td><td>5000</td></tr><tr><td>—-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>杰克琼斯</td><td>800</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>真维斯</td><td>200</td></tr><tr><td>——</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>花花公子</td><td>440</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>劲霸</td><td>2000</td></tr><tr><td>—-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>香奈儿</td><td>800</td></tr><tr><td>——</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>相一本草</td><td>200</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>面霸</td><td>5</td></tr><tr><td>—-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>好想你枣</td><td>56</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>香飘飘奶茶</td><td>2</td></tr><tr><td>———-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>海澜之家</td><td>1</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>辉辉</td><td>5000</td></tr><tr><td>—-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>+————+——-+</td><td></td></tr></tbody></table><p>select pname from product as p;  给表起别名 </p><p>select pname as 商品名 from product as p; 给列起别名</p><p>select pname as pn from product;  </p><p>select distinct price from product;  取重复</p><p>select pname,price+10 from product;  查询结果是表达式  将所用商品的价格+10进行显示</p><h2 id="分组查询-分页查询"><a href="#分组查询-分页查询" class="headerlink" title="分组查询  分页查询"></a>分组查询  分页查询</h2><p>删除语句  加条件<br>delect from product where pid &gt; 13; </p><p>分组查询</p><p>统计各类商品的个数<br>select category_id,count(*) from product group by category_id;</p><p>sql语句执行顺序</p><p>from &gt; where &gt; group by &gt; 聚合函数 &gt; having &gt; select &gt; order by &gt; limit </p><p>分组以后  select 的后面只能跟分组字段和聚合函数  </p><p>  select category_id,count(<em>) from product group by category_id having count(</em>) &gt;1;</p><p>  having 是在分组后对数据进行过滤 where是在分组前对数据进行过滤 </p><p>  分页查询:<br>  select from limit M,N;<br>M 是下标 下标从0开始  N 是显示的条数 limit M,N;<br>每页显示多少条记录每页显示5条<br>第一页  limit 0,5</p><p>insert into select  语句从一个表中复制数据 然后把数据插入到另一个表中；</p><p>insert into product2 select pid,pname,price from product where category_id = ‘c001’;</p><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>1支持如下运算</p><p><img src="https://img-blog.csdn.net/20180318220938450?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTIzMjUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lazyload placeholder" data-srcset="https://img-blog.csdn.net/20180318220938450?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTIzMjUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>select * from product where pname = ‘花花公子’;  商品查询</p><p> select * from product where price = 800;  </p><p> select * from product where price != 800; 价格不等于800</p><p> select * from product where price &lt;&gt; 800; 价格不等于800</p><p> select * from product where price not(price = 800); 价格不等于800</p><p> select * from product where pname like ‘花%’;   查询以 花 开头的商品</p><p> select * from product where pname like ‘%花%’;      查询所有含 花 的商品</p><p> select * from product where pname like ‘_想%’;  查询第二个字为想的商品</p><p> select * from product where category_id is null;</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p> select * from 表名 order by 排序字段 asc  默认是升序 </p><p> select *from product order by price asc; 升序</p><p> select *from product order by price desc; 降序</p><h2 id="表与表的关系"><a href="#表与表的关系" class="headerlink" title="表与表的关系"></a>表与表的关系</h2><h4 id="表与表的关系-1"><a href="#表与表的关系-1" class="headerlink" title="表与表的关系"></a>表与表的关系</h4><p>   一对一的关系</p><p>   一对多的关系</p><p>   多对多的关系</p><p>主键列 控制 外键列</p><p>alter table product  修改表<br>add constraint product_fk   添加<br>foreign key(category_id) references category(cid);            </p><h4 id="内连接查询-（两张表的交集）"><a href="#内连接查询-（两张表的交集）" class="headerlink" title="内连接查询  （两张表的交集）"></a>内连接查询  （两张表的交集）</h4><p>  1 隐藏式内连接查询   select * from A, B where 条件<br>  2 查询哪个分类下面有那些商品  </p><p>  select * from category a,products b where a,cid = b.category_id;<br>  select a,cname,b pname from category1 a,product1 b where a,cid = b.category_id;<br>显示连接  select * from A inner join B on 条件<br>select * from category a inner product1 b on a.cid = b.category_id;</p><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>查询 （关键字 outer join outer join B on 条件<br>    外连接 left outer join<br>      select  * from A left outer join B on 条件<br>    右连接 right outer join<br>      select * from A right outer join B on 条件</p><blockquote><p>select * from category1 a left outer join product b on a.cid = b.category_id;</p></blockquote><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><p>子查询1<br>其实就是 select 的嵌套 select * from (select * from (select * from))<br>    select * from<br>        product1 p<br>    where<br>        p.category_id = (select cid category1 where cname =’化妆品’);</p><p>让商品表里查询价格  等于  最高价格</p><p>mysql&gt; select * from product1 where price = (select max(price) from producr1);</p><p>字查询可以 作为一个临时表<br>se<br>    select* from product1 p,</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>select abs (-8) – 绝对值<br>select ceiling(9.4) –向上去整<br>select floor(9.4)  –向下取整数<br>select rand()  –返回一个0 ~ 1 直接的随机数<br>select sign(10)  – 判断一个数的符号  负数返回—1  正数返回1</p><p>  字符串函数<br> select char_length(‘即使再小的帆也能远航’)  字符串长度<br> select concat (‘wo’,’ai’,’nimen’) –拼接字符串</p><h2 id="开窗函数"><a href="#开窗函数" class="headerlink" title="开窗函数"></a>开窗函数</h2><p>​    用来直接排序等等</p><p>create table employee1 (empid int,ename varchar(20),deptid int,salary decimal(10,2));<br>insert into employee1 values(1,’刘备’,10,5500.00);<br>insert into employee1 values(2,’赵云’,10,4500.00);<br>insert into employee1 values(3,’张飞’,10,4500.00);<br>insert into employee1 values(4,’关羽’,10,3500.00);<br>insert into employee1 values(5,’曹操’,10,6500.00);<br>insert into employee1 values(6,’许褚’,10,5600.00);<br>insert into employee1 values(7,’张辽’,10,5400.00);<br>insert into employee1 values(8,’徐晃’,10,4500.00);</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>原子性<br> 要么都成功 要么都失败<br>一致性<br> 事务前后的数据都保持一致<br>持久性<br>  事务一旦提交   表示事务结束后的数据不随着外界原因导致数据丢失<br>隔离性<br>  事务的隔离是多个用户并发访问数据库时 数据库为每一个用户的事务 不被其他事务所干扰，<br>  多个并发的事务之间要相互隔离</p><p>  –mysql 是默认开启事务自动提交的<br>  set autocommit = 0 关闭<br>  set autocommit = 1 开启</p><p>–手动处理事务<br>set autocommit = 0 – 关闭自动提交</p><p>–事务开启<br>start transaction – 标记一个事务的开始 ， 从这个之后的sql都在同一个事务内</p><p>insert xx<br>insert xx</p><p>–提交 持久话<br>commit<br>–回滚 回到原来的样子<br>rollback<br>–事务结束<br>set autocommit = 1 –开启自动提交</p><p>–了解<br>sevepoint 保存点名  设置一个事务的保存点<br>pollback to savepoint 保存点名  回滚到保存点<br>release savepoint 保存点名 –</p><h2 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h2><p>权限管理    用户管理</p><p>MySQL 数据库备份的方式</p><p>​    1.直接拷贝物理文件</p><p>​    2.直接设置数据库的设计<br>​    </p><pre><code>良好的数据库  节省内存空间  保证数据库的完整行  方便我们开发系统设计数据库步骤  收集信息 分析需求   用户表（用户登录注销 用户的个人信息  写博客 创建分类   分类表   文章表   友链表   自定义表    标识体</code></pre><p>三大范式<br>    信息重复</p><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，<br>    就说明该数据库表满足了第一范式。</p><p>第二范式(确保表中的每列都和主键相关)<br>  第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关 ，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p> 第三范式(确保每列都和主键列直接相关,而不是间接相关)<br>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。<br>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立<br>相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。<br>如下面这两个表所示的设计就是一个满足第三范式的数据库表。</p><p> 规范性和性能的问题<br>      关联的表不得超过三张表<br>      考虑商业化的需求和目标 （成本，用户体验） 数据库的性能更加重要<br>      在规范性能的问题的时候 需要适当的考虑一下规范性<br>      故意给某些表增加一下字段 （从多表查询标为单表查询）</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引的分类<br>    1  树索引<br>    2  哈希索引</p><p>创建索引<br>    create i ndex price_indexN-<br>    amei ON mytable(username([length]);</p><pre><code>create index price_index on product1(price);</code></pre><p>方式2  修改表的结构<br>    alter table product1 sdd index pname_index(pname);<br>方式3  创建表的时候指定<br>    create table myable(<br>     id int not null,<br>     username varchar(16) notnull,<br>     index username_index(username);</p><p>查看索引<br>    show index from product1;<br>查看表的索引<br>    select * from mysql.inndb_index_stats<code>a where a,</code>database_name `=’数据库’;</p><p>查看某一表的索引<br>        select * from mysql.inndb_index_stats<code>a where a,</code>database_name <code>=&#39;数据库&#39;and     a.table_name like&#39;%表名%&#39;;     select * from mysql.inndb_index_stats</code>a where a,<code>database_name </code>=’bigdata_db’and a.table_name like’%product1%’;</p><p>删除索引<br>    drop index [名字] on product1;</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组讲解</title>
      <link href="/2022/0404undefined.html"/>
      <url>/2022/0404undefined.html</url>
      
        <content type="html"><![CDATA[<h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><p>​    想必学过数据结构的同学都知道数组了，接下来就带大家了解一下。</p><h3 id="1-数组的存储方式"><a href="#1-数组的存储方式" class="headerlink" title="1 数组的存储方式"></a>1 数组的存储方式</h3><p>​    数组是通过下标索引获取的方式到下标下对应的数据，数组是存放在内存空间的，每一个数都对应的一个相对地址。我在这里不过多的赘述了，具体的大家去查资料。</p><h3 id="2-注意两点"><a href="#2-注意两点" class="headerlink" title="2 注意两点"></a>2 注意两点</h3><p>   · 数组下标都是从0开始的<br>   · 数组内存空间的地址都是连续的</p><p>首先从leetcode的第一题开始说起两数之和，这一题有多种解法，我从暴力破解和HashMap两种开始讲解。</p><p><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></p><p>第一种双重for循环也为暴力破解</p><p>​    如果使用暴力破解不会 大家就想想学的<a href="https://www.baidu.com/s?ie=UTF-8&wd=%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95">冒泡算法</a>  是不是使用双指针先确定一个依次循环然后遍历并且相加得到值进行比较。</p><p>注意返回的格式 ” new int[] {i,j} “ </p><p>第二中方法 哈希表</p><p>​    如果对哈希表了解不是很全面，到<a href="https://turingplanet.org/2020/03/08/%e5%93%88%e5%b8%8c%e8%a1%a8-hash-table%e3%80%8c%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%92%8c%e7%ae%97%e6%b3%956%e3%80%8d/#ha_xi_biao_de_gai_nian">哈希表</a>来了解，总之算法不是一天修成，大家持之以恒终有一天会成为算法大佬（我也是菜鸟）</p><p>整个for循环我相信大家可以理解 但是对于 <a href="https://www.runoob.com/java/java-hashmap-containskey.html">“ map.containsKey(target - nums[i]) ”</a> 肯定理解不是很到位，可以到菜鸟教程了解，也可以点击我给的超链接， 注意返回的格式 ” new int[] {i,j} “ 。</p><pre class="line-numbers language-none"><code class="language-none">hashmap.containsKey(Object key)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 如果 hashMap 中存在指定的 key 对应的映射关系返回 true，否则返回 false。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int[] twoSum(int[] nums, int target) &#123;            第一种解法         int let &#x3D; nums.length;         for(int i &#x3D; 0;i &lt; let;i++)&#123;             for(int j &#x3D; i + 1; j &lt; let; ++j)&#123;                 if(nums[i]+nums[j] &#x3D;&#x3D; target)&#123;                     return new int[] &#123;i,j&#125;;                     &#x2F;&#x2F;注意返回的形式 我第一踩的坑就是不会返回 new的数组。                 &#125;             &#125;         &#125;第二种解法        Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();        for(int i &#x3D; 0;i&lt;nums.length;i++)&#123;             &#x2F;&#x2F; 如果 hashMap 中存在指定的 key 对应的映射关系返回 true，否则返回 false。            if(map.containsKey(target - nums[i]))&#123;                return new int[]&#123;map.get(target - nums[i]),i&#125;;            &#125;            map.put(nums[i],i);        &#125;                return new int[2];    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>忠告大家：</p><p>​    · 练习算法千万不能直接复制粘贴，哪怕不会做没有思路，也千万不用复制粘贴。实在不跟着思路抄一遍，只会有益无害。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/0330undefined.html"/>
      <url>/2022/0330undefined.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>本站说明</title>
      <link href="/2022/0301undefined.html"/>
      <url>/2022/0301undefined.html</url>
      
        <content type="html"><![CDATA[<pre><code>本站只用于学习参考，如有错误请即使指出，大家一起进步一起成长。</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
