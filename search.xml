<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/0704undefined.html"/>
      <url>/2022/0704undefined.html</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="source%5Cimg%5Cerfen.jpg" class="lazyload placeholder" data-srcset="source%5Cimg%5Cerfen.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;        int[] arr &#x3D; &#123;19, 41, 50, 93, 135, 210, 386&#125;;        erFen(arr, 41);        System.out.println(Arrays.toString(arr));    &#125;    public static void erFen(int[] arr, int t) &#123;        &#x2F;&#x2F;首先二分查找是在一个有序数组中进行的        &#x2F;&#x2F;每次都是找到数组的没一半来锁定所查找的值        int left &#x3D; 0;&#x2F;&#x2F;定义一个左指针        int right &#x3D; arr.length;&#x2F;&#x2F;定义右指针        while (left &lt; right) &#123;            int middle &#x3D; (left + right) &#x2F; 2;&#x2F;&#x2F;中间值在随着左右指针移动而改变这样才能缩小范围            if (arr[middle] &#x3D;&#x3D; t) &#123;                System.out.println(&quot;下标为&quot; + middle);                return;            &#125;            &#x2F;&#x2F;当t 大于middle时，说明t在中间值的右边，然后把做指针指先中间并++，++的作用不至于出现死循环            if (arr[middle] &lt; t) &#123;                left &#x3D; middle;                left++;            &#125;            &#x2F;&#x2F;当t 小于middle时，说明t在中间值的左边，然后把做指针指先中间并--，--的作用不至于出现死循环            if (arr[middle] &gt; t) &#123;                right &#x3D; middle;                right--;            &#125;        &#125;        System.out.println(&quot;没有找到&quot;);    &#125;    &#x2F;&#x2F;使用递归    &#x2F;&#x2F;递归同理，区别就是将循环使用到递归中，将左右指针传入到递归中    public static void erFenSelect1(int[] arr, int t1, int l, int r) &#123;        int left &#x3D; l;        int right &#x3D; r;        int middle &#x3D; (left + right) &#x2F; 2;        if (arr[middle] &#x3D;&#x3D; t1) &#123;            System.out.println(middle);            return;        &#125;        if (arr[middle] &gt; t1) &#123;            right &#x3D; middle;            right--;        &#125;        if (arr[middle] &lt; t1) &#123;            left &#x3D; middle;            left++;        &#125;        if (left &gt;&#x3D; right) &#123;            System.out.println(&quot;没有找到&quot;);            return;        &#125;        erFenSelect1(arr, t1, left, right);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2022/0629undefined.html"/>
      <url>/2022/0629undefined.html</url>
      
        <content type="html"><![CDATA[<p>快速排序</p><p>快速排序了就是使用了分治法</p><p>给你一堆数</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int[] arr &#x3D; &#123;19,41,50,93,35,10,86&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你只需要随便拿出一个数作为基数 然后将比较后的数，如果大于等于基数就放到右边 同理如果小于等于基数就放到左边。</p><p>定义两指针</p><p>例如  基数19 和 86分别被左指针和右指针所指。</p><p>左指针指的19是等于基数的所以19 不动  只动指针，将左指针先右移动一位，</p><p>右指针指的 86是大于基数19的 所以89不动 将右指针先左移动一位。</p><p>左指针 指先下一个41 大于基数19 ， 右指针10 小于基数19，</p><p>因为刚好左右都进行了比较，如果说41 是18 指针还是先右移，一直移动到可以左右交换为止，</p><p>使用一个额外的指针进行交换。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void main(String[] args) &#123;        quicksort(arr,0,arr.length-1);        System.out.println(Arrays.toString(arr));    &#125;    public static void quicksort(int[] arr,int low,int high)&#123;        int i ,j,temp,t;        if (low&gt;high)&#123;            return;        &#125;        i &#x3D; low;        j &#x3D; high;        temp &#x3D; arr[low];        while (i &lt; j)&#123;            &#x2F;&#x2F;判断大于基数的话就在右边 指针不动  小于基数的话指针左移就是--            while (i &lt; j &amp;&amp; temp &lt;&#x3D; arr[j])&#123;                j--;            &#125;            &#x2F;&#x2F;判断小于基数的话就在左边 指针不动 小于基数的话指针右移 ++            while (i &lt; j &amp;&amp; temp &gt;&#x3D; arr[i])&#123;                i++;            &#125;            if(i &lt; j)&#123;                &#x2F;&#x2F;上面判断完一轮后利用指针进行移动。                t &#x3D; arr[i];                arr[i] &#x3D; arr[j];                arr[j] &#x3D; t;            &#125;        &#125;        &#x2F;&#x2F;因为你已经分程了两类  你现在需要将你左边的 第一个等于 标记的基数， 右边的第一个等于标记的基数        &#x2F;&#x2F;此处是为了将每次定义的每段数组的第一个值指向为基数。        arr[low] &#x3D; arr[i];        arr[i] &#x3D; temp;        &#x2F;&#x2F;左边进行递归调用        quicksort(arr,low,j-1);        quicksort(arr,j+1,high);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2022/0629undefined.html"/>
      <url>/2022/0629undefined.html</url>
      
        <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 </p><p><img src="C:\Users\辉辉\Desktop\笔记\img\charu.jpg" class="lazyload placeholder" data-srcset="C:\Users\辉辉\Desktop\笔记\img\charu.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="charu"></p><p>定义两层循环，第一次循环为大循环，第二次循环是来进行比较，并且来调换位置。注意的是在第二次循环时的 j 的值，每次循环的时候，都是和前面排序好的进行比较，</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void main(String[] args) &#123;    int[] arr &#x3D; &#123;21,231,89,27,483,7,49&#125;;    insert(arr);    System.out.println(Arrays.toString(arr));&#125;public static void insert(int[] arr)&#123;    int temp &#x3D; 0;    for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;        for (int j &#x3D; 0 ;j &lt; i;j++) &#123;&#x2F;&#x2F;循环的时候是小于i的所在值            if (arr[j] &lt; arr[j + 1]) &#123;                &#x2F;&#x2F;比较并且交换                temp &#x3D; arr[j];                arr[j] &#x3D; arr[j+1];                arr[j+1] &#x3D; temp;            &#125;        &#125;        System.out.println(Arrays.toString(arr));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2022/0629undefined.html"/>
      <url>/2022/0629undefined.html</url>
      
        <content type="html"><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><img src="D:\Download\项目\BLOG\hexoblog\source\img\xuanz.jpg" class="lazyload placeholder" data-srcset="D:\Download\项目\BLOG\hexoblog\source\img\xuanz.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="xuanz"></p><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><p>选择排序就是说，首先定义一个下标，指定一个第一个数，定义两层循环，第一层循环，为大规模循环，每次的 i 指针都加 1 并且指向所定义的下标，</p><p>定义第二次循环，每次循环都是将最小的指针替换为所定义的指针。</p><p>public static void main(String[] args) {<br>    int[] arr = {21,231,89,27,483,7,49};<br>    selectSort(arr);<br>    System.out.println(Arrays.toString(arr));<br>}</p><p>public static void selectSort(int[] arr){</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void main(String[] args) &#123;    int[] arr &#x3D; &#123;21,231,89,27,483,7,49&#125;;    selectSort(arr);    System.out.println(Arrays.toString(arr));&#125;public static void selectSort(int[] arr)&#123;int index &#x3D; 0;int temp &#x3D; 0;for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;    &#x2F;&#x2F;定义一个指针来随机所指一个数    index &#x3D; i;    for (int j &#x3D; i; j &lt; arr.length; j++) &#123;        if (arr[j] &lt; arr[index])&#123;&#x2F;&#x2F;在循环的过程中进行比较将最小的值指向所定的指针            index &#x3D; j;        &#125;    &#125;    temp &#x3D; arr[i];    arr[i] &#x3D; arr[index];    arr[index] &#x3D; temp;    System.out.println(Arrays.toString(arr));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包装类</title>
      <link href="/2022/0628undefined.html"/>
      <url>/2022/0628undefined.html</url>
      
        <content type="html"><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>Java有八种基本类型，每种基本类型都有一个对应的包装类。 </p><p>Java中，基本类型和对应的包装类如下表所示：</p><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table><p>包装类也都很好记，除了Integer和Character外，其他类名称与基本类型基本一样，只是首字母大写。</p><h3 id="基本类型和包装类"><a href="#基本类型和包装类" class="headerlink" title="基本类型和包装类"></a><strong>基本类型和包装类</strong></h3><p><strong>Boolean</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">boolean b1 &#x3D; false;Boolean bObj &#x3D; Boolean.valueOf(b1);boolean b2 &#x3D; bObj.booleanValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Byte</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">byte b1 &#x3D; 123;Byte byteObj &#x3D; Byte.valueOf(b1);byte b2 &#x3D; byteObj.byteValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Short</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">short s1 &#x3D; 12345;Short sObj &#x3D; Short.valueOf(s1);short s2 &#x3D; sObj.shortValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Integer</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int i1 &#x3D; 12345;Integer iObj &#x3D; Integer.valueOf(i1);int i2 &#x3D; iObj.intValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Long</strong>Java</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">long l1 &#x3D; 12345;Long lObj &#x3D; Long.valueOf(l1);long l2 &#x3D; lObj.longValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Float</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">float f1 &#x3D; 123.45f;Float fObj &#x3D; Float.valueOf(f1);float f2 &#x3D; fObj.floatValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Double</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">double d1 &#x3D; 123.45;Double dObj &#x3D; Double.valueOf(d1);double d2 &#x3D; dObj.doubleValue(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Character</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">char c1 &#x3D; &#39;A&#39;;Character cObj &#x3D; Character.valueOf(c1);char c2 &#x3D; cObj.charValue(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Java1-5后的技术"><a href="#Java1-5后的技术" class="headerlink" title="Java1.5后的技术"></a>Java1.5后的技术</h3><p>java 1.5以后引入了自动装箱和拆箱技术，可以直接将基本类型赋值给引用类型，反之亦可，如下代码所示：</p><pre class="line-numbers language-none"><code class="language-none">Integer a &#x3D; 100;int b &#x3D; a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>自动装箱/拆箱是Java编译器提供的能力，背后，它会替换为调用对应的valueOf()/xxxValue()，比如说，上面的代码会被Java编译器替换为：</p><pre class="line-numbers language-none"><code class="language-none">Integer a &#x3D; Integer.valueOf(100);int b &#x3D; a.intValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>每种包装类也都有构造方法，可以通过new创建，比如说：</p><pre class="line-numbers language-none"><code class="language-none">Integer a &#x3D; new Integer(100);Boolean b &#x3D; new Boolean(true);Double d &#x3D; new Double(12.345);Character c &#x3D; new Character(&#39;马&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所有的包装类都重写了Object类</p><p>在equals中是用于判断当前对象和参数传入的对象是否相同，Object类的默认实现是比较地址，</p><p>Float有一个静态方法floatToIntBits()，将float的二进制表示看做int。需要注意的是，只有两个float的二进制表示完全一样的时候，equals才会返回true。 </p><p>Double的equals方法与Float类似，它有一个静态方法doubleToLongBits，将double的二进制表示看做long，然后再按long比较。 </p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>包装类都重写了hashCode，根据包装的基本类型值计算hashCode，对于Byte, Short, Integer, Character，hashCode就是其内部值 </p><p>hashCode 返回一个对象的哈希值，哈希值是一个int类型的数，由对象中一般不变的属性映射得来，用于快速对对象进行区分、分组等。一个对象的哈希值不能变，相同对象的哈希值必须一样。 不同对象的哈希值一般应不同，但这不是必须的，可以有不同对象但哈希值相同的情况。 </p><p>hashCode和equals方法联系密切，对两个对象，如果equals方法返回true，则hashCode也必须一样。反之不要求，equal返回false时，hashCode可以一样，也可以不一样，但应该尽量不一样。hashCode的默认实现一般是将对象的内存地址转换为整数，子类重写equals时，也必须重写hashCode。之所以有这个规定，是因为Java API中很多类依赖于这个行为，尤其是集合中的一些类。</p><p>  1.如果两个对象相同，那么它们的hashCode值一定要相同；<br>  2.如果两个对象的hashCode相同，它们并不一定相同<br>  （这里说的对象相同指的是用eqauls方法比较）。<br>    如不按要求去做了，会发现相同的对象可以出现在Set集合中，<br>    同时，增加新元素的效率会大大下降。<br>  3.equals()相等的两个对象，hashcode()一定相等；<br>  equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>包装类都重写了hashCode，根据包装的基本类型值计算hashCode，对于Byte, Short, Integer, Character，hashCode就是其内部值， </p><p><strong>Comparable</strong></p><p>每个包装类也都实现了Java API中的Comparable接口，Comparable接口代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public interface Comparable&lt;T&gt; &#123;    public int compareTo(T o);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="包装类和String"><a href="#包装类和String" class="headerlink" title="包装类和String"></a><strong>包装类和String</strong></h3><p>除了toString方法外，包装类还有一些其他与String相关的方法。</p><p>除了Character外，每个包装类都有一个静态的valueOf(String)方法，根据字符串表示返回包装类对象，如：</p><pre class="line-numbers language-none"><code class="language-none">Boolean b &#x3D; Boolean.valueOf(&quot;true&quot;);Float f &#x3D; Float.valueOf(&quot;123.45f&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也都有一个静态的parseXXX(String)方法，根据字符串表示返回基本类型值，如：</p><pre class="line-numbers language-none"><code class="language-none">boolean b &#x3D; Boolean.parseBoolean(&quot;true&quot;);double d &#x3D; Double.parseDouble(&quot;123.45&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>都有一个静态的toString()方法，根据基本类型值返回字符串表示，如：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">System.out.println(Boolean.toString(true));System.out.println(Double.toString(123.45));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="常用常量"><a href="#常用常量" class="headerlink" title="常用常量"></a><strong>常用常量</strong></h3><p>包装类中除了定义静态方法和实例方法外，还定义了一些静态变量。</p><p>Boolean类型：</p><pre class="line-numbers language-none"><code class="language-none">public static final Boolean TRUE &#x3D; new Boolean(true);public static final Boolean FALSE &#x3D; new Boolean(false);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>所有数值类型都定义了MAX_VALUE和MIN_VALUE，表示能表示的最大/最小值，比如，对Integer：</p><pre class="line-numbers language-none"><code class="language-none">public static final int   MIN_VALUE &#x3D; 0x80000000;public static final int   MAX_VALUE &#x3D; 0x7fffffff;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Float和Double还定义了一些特殊数值，比如正无穷、负无穷、非数值，如Double类：</p><pre class="line-numbers language-none"><code class="language-none">public static final double POSITIVE_INFINITY &#x3D; 1.0 &#x2F; 0.0;public static final double NEGATIVE_INFINITY &#x3D; -1.0 &#x2F; 0.0;public static final double NaN &#x3D; 0.0d &#x2F; 0.0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a><strong>Number</strong></h3><p>六种数值类型包装类有一个共同的父类Number，Number是一个抽象类，它定义了如下方法：</p><pre class="line-numbers language-none"><code class="language-none">byte byteValue()short shortValue()                int intValue()long longValue()float floatValue()double doubleValue()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以返回任意的基本数值类型。</p><h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性**"></a>不可变性**</h3><p>包装类都是不可变类，所谓不可变就是，实例对象一旦创建，就没有办法修改了。这是通过如下方式强制实现的：</p><ul><li>所有包装类都声明为了final，不能被继承</li><li>内部基本类型值是私有的，且声明为了final</li><li>没有定义setter方法</li></ul><p>为什么要定义为不可变类呢？不可变使得程序可以更为简单安全，因为不用操心数据被意外改写的可能了，可以安全的共享数据，尤其是在多线程的环境下</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举</title>
      <link href="/2022/0625undefined.html"/>
      <url>/2022/0625undefined.html</url>
      
        <content type="html"><![CDATA[<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="枚举的定义"><a href="#枚举的定义" class="headerlink" title="枚举的定义"></a>枚举的定义</h3><p>枚举类的使用enum（它与class、interface关键字地位相同）关键字定义。一个java源文件中只能有一 个public修饰的枚举类，且java源文件也必须和枚举类的类名相同。  下面来定义一个枚举类： </p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public enum TestDemo&#123; SPRING,SUMMER,FALL,WINTER &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="枚举的好处"><a href="#枚举的好处" class="headerlink" title="枚举的好处"></a>枚举的好处</h3><ul><li>定义枚举的语法更为简洁。</li><li>枚举更为安全，一个枚举类型的变量，它的值要么为null，要么为枚举值之一，不可能为其他值，但使用整形变量，它的值就没有办法强制，值可能就是无效的。</li><li>枚举类型自带很多便利方法(如values, valueOf, toString等)，易于使用。 </li></ul><h3 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h3><p>枚举类型实际上会被Java编译器转换为一个对应的类，这个类继承了Java API中的java.lang.Enum类。</p><p>Enum类有两个实例变量name和ordinal，在构造方法中需要传递，name(), toString(), ordinal(), compareTo(), equals()方法都是由Enum类根据其实例变量name和ordinal实现的。</p><h3 id="枚举类和普通类的区别"><a href="#枚举类和普通类的区别" class="headerlink" title="枚举类和普通类的区别"></a><strong>枚举类和普通类的区别</strong></h3><ol><li><p>枚举类可以实现一个或多个接口，使用eunm定义的类默认继承了java.lang.Enum类，而不是默认 继承Object类，因此枚举类不能显示继承其他父类。其中java.lang.Enum类实现了 java.lang.Serializable和java.lang.Comparable接口</p></li><li><p>非抽象的枚举类默认会使用final修饰，因此枚举类不能派生子类。 </p></li><li><p>枚举类的构造器只能使用private修饰，如果省略，系统默认使用private修饰。</p></li><li><p>枚举类的每一个实例必须显示声明，每个实例使用逗号隔开。</p></li></ol><h3 id="枚举类默认有如下方法"><a href="#枚举类默认有如下方法" class="headerlink" title="枚举类默认有如下方法"></a>枚举类默认有如下方法</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">values()方法   该方法可以很方便的遍历所有的枚举值&#x2F;** * @Author Gw_gw * @Date 2021&#x2F;6&#x2F;12 18:50 * @Version 1.0 *&#x2F;public class  TestDemo&#123;public static void main(String[] args) &#123;&#x2F;&#x2F;使用values()方法来遍历枚举类的值for(Season i : Season.values())&#123;System.out.println(i);&#125;&#125;&#125;&#x2F;** * 枚举类表示四季 *&#x2F;enum Season&#123;&#x2F;** * 春夏秋冬 *&#x2F;SPRING,SUMMER,FALL,WINTER;&#125;ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。public class  TestDemo&#123;public static void main(String[] args) &#123;&#x2F;&#x2F;使用values()方法来赋值Season[] season &#x3D; Season.values();for(Season i : season)&#123;System.out.println(i+&quot;的索引是&quot;+i.ordinal());&#125;&#125;&#125;valueOf()方法返回指定字符串值的枚举常量。不存在的会报错 IllegalArgumentExceptionpublic class  TestDemo&#123;public static void main(String[] args) &#123;&#x2F;&#x2F; 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentExceptionSystem.out.println(Season.valueOf(&quot;SPRING&quot;));&#x2F;&#x2F;error  IllegalArgumentExceptionSystem.out.println(Season.valueOf(&quot;asd&quot;));&#125;&#125;compareTo(E o)方法  指定枚举对象的比较顺序。如果枚举对象在指定枚举对象之后返回正整数，之前返回正整数，否则返回0public class  TestDemo&#123;public static void main(String[] args) &#123;&#x2F;&#x2F;返回-1System.out.println(Season.SPRING.compareTo(Season.SUMMER));&#125;&#125;String name() :返回此枚举实例的名称String toString():返回枚举常量的名称toString()方法更常用public class  TestDemo&#123;public static void main(String[] args) &#123;System.out.println(Season.SPRING.name());System.out.println(Season.SPRING.toString());&#x2F;&#x2F;实质就是调用toString()方法System.out.println(Season.SPRING);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="枚举类的成员变量和构造器"><a href="#枚举类的成员变量和构造器" class="headerlink" title="枚举类的成员变量和构造器"></a>枚举类的成员变量和构造器</h3><p>枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所 以外部无法调用。</p><p> 枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都 必须实现它。 </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常</title>
      <link href="/2022/0624undefined.html"/>
      <url>/2022/0624undefined.html</url>
      
        <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>之前我们介绍的基本类型、类、接口、枚举都是在表示和操作数据，操作的过程中可能有很多出错的情况，出错的原因可能是多方面的，有的是不可控的内部原因，比如内存不够了、磁盘满了，有的是不可控的外部原因，比如网络连接有问题，更多的可能是程序的编程错误，比如引用变量未初始化就直接调用实例方法。 </p><p>java使用异常机制统一来处理，内容较多</p><p><strong>NullPointerException (空指针异常)</strong> </p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class ExceptionTest &#123;    public static void main(String[] args) &#123;        String s &#x3D; null;        s.indexOf(&quot;a&quot;);        System.out.println(&quot;end&quot;);    &#125;&#125;变量s没有初始化就调用其实例方法indexOf，Exception in thread &quot;main&quot; java.lang.NullPointerException    at ExceptionTest.main(ExceptionTest.java:5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>NumberFormatException (数字格式异常)</strong> </p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class ExceptionTest &#123;    public static void main(String[] args) &#123;        if(args.length&lt;1)&#123;            System.out.println(&quot;请输入数字&quot;);            return;        &#125;        int num &#x3D; Integer.parseInt(args[0]);        System.out.println(num);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的类都可用捕获”是指使用try/catch关键字 </p><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>NullPointerException和NumberFormatE</p><pre class="line-numbers language-none"><code class="language-none">xception都是异常类，所有异常类都有一个共同的父类Throwable，它有4个public构造方法：1. public Throwable()2. public Throwable(String message)3. public Throwable(String message, Throwable cause)4. public Throwable(Throwable cause) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有两个主要参数，一个是message，表示异常消息，另一个是cause，表示触发该异常的其他异常。异常可以形成一个异常链，上层的异常由底层异常触发，cause表示底层异常。</p><p>Throwable还有一个public方法用于设置cause：</p><pre class="line-numbers language-none"><code class="language-none">Throwable initCause(Throwable cause)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Throwable的某些子类没有带cause参数的构造方法，就可以通过这个方法来设置，这个方法最多只能被调用一次。</p><p>所有构造方法中都有一句重要的函数调用：</p><pre class="line-numbers language-none"><code class="language-none">fillInStackTrace();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会将异常栈信息保存下来，这是我们能看到异常栈的关键。</p><p>Throwable有一些常用方法用于获取异常信息：</p><pre class="line-numbers language-none"><code class="language-none">void printStackTrace()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打印异常栈信息到标准错误输出流，它还有两个重载的方法：</p><pre class="line-numbers language-none"><code class="language-none">void printStackTrace(PrintStream s)void printStackTrace(PrintWriter s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打印栈信息到指定的流，关于PrintStream和PrintWriter我们后续文章介绍。</p><pre class="line-numbers language-none"><code class="language-none">String getMessage()Throwable getCause()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获取设置的异常message和cause</p><pre class="line-numbers language-none"><code class="language-none">StackTraceElement[] getStackTrace()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取异常栈每一层的信息，每个StackTraceElement包括文件名、类名、函数名、行号等信息。</p><h3 id="异常类体系"><a href="#异常类体系" class="headerlink" title="异常类体系"></a><strong>异常类体系</strong></h3><p>以Throwable为根，Java API中定义了非常多的异常类，表示各种类型的异常，部分类示意如下：</p><p><img src="https://images2015.cnblogs.com/blog/924211/201607/924211-20160707195250233-1530995915.jpg" class="lazyload placeholder" data-srcset="https://images2015.cnblogs.com/blog/924211/201607/924211-20160707195250233-1530995915.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="img"> </p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a><strong>自定义异常</strong></h3><p>除了Java API中定义的异常类，我们也可以自己定义异常类，一般通过继承Exception或者它的某个子类，如果父类是RuntimeException或它的某个子类，则自定义异常也是unchecked exception，如果是Exception或Exception的其他子类，则自定义异常是checked exception。</p><p>我们通过继承Exception来定义一个异常，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class AppException extends Exception &#123;    public AppException() &#123;        super();    &#125;    public AppException(String message,            Throwable cause) &#123;        super(message, cause);    &#125;    public AppException(String message) &#123;        super(message);    &#125;    public AppException(Throwable cause) &#123;        super(cause);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和很多其他异常类一样，我们没有定义额外的属性和代码，只是继承了Exception，定义了构造方法并调用了父类的构造方法。</p><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a><strong>throws</strong></h3><p>异常机制中，还有一个和throw很像的关键字throws，用于声明一个方法可能抛出的异常，语法如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void test() throws AppException, SQLException, NumberFormatException &#123;    &#x2F;&#x2F;....&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a><strong>finally</strong></h3><p>异常机制中还有一个重要的部分，就是finally, catch后面可以跟finally语句，语法如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">try&#123;    &#x2F;&#x2F;可能抛出异常&#125;catch(Exception e)&#123;    &#x2F;&#x2F;捕获异常&#125;finally&#123;    &#x2F;&#x2F;不管有无异常都执行&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Checked对比Unchecked-Exception"><a href="#Checked对比Unchecked-Exception" class="headerlink" title="Checked对比Unchecked Exception"></a><strong>Checked对比Unchecked Exception</strong></h3><p>以上，可以看出RuntimeException(unchecked exception)和checked exception的区别，checked exception必须出现在throws语句中，调用者必须处理，Java编译器会强制这一点，而RuntimeException则没有这个要求。 </p><p>Java被广泛应用于服务器程序中，不能因为一个逻辑错误就使程序退出。所以，目前一种更被认同的观点是，Java中的这个区分是没有太大意义的，可以统一使用RuntimeException即unchcked exception来代替。 </p><p>这个观点的基本理由是，无论是checked还是unchecked异常，无论是否出现在throws声明中，我们都应该在合适的地方以适当的方式进行处理，而不是只为了满足编译器的要求，盲目处理异常，既然都要进行处理异常，checked exception的强制声明和处理就显得啰嗦，尤其是在调用层次比较深的情况下。 </p><h3 id="异常处理的目标"><a href="#异常处理的目标" class="headerlink" title="异常处理的目标"></a><strong>异常处理的目标</strong></h3><p>异常大概可以分为三个来源：用户、程序员、第三方。用户是指用户的输入有问题，程序员是指编程错误，第三方泛指其他情况如I/O错误、网络、数据库、第三方服务等。每种异常都应该进行适当的处理。</p><p>处理的目标可以分为报告和恢复。恢复是指通过程序自动解决问题。报告的最终对象可能是用户，即程序使用者，也可能是系统运维人员或程序员。报告的目的也是为了恢复，但这个恢复经常需要人的参与。</p><p>对用户，如果用户输入不对，可能提示用户具体哪里输入不对，如果是编程错误，可能提示用户系统错误、建议联系客服，如果是第三方连接问题，可能提示用户稍后重试。</p><p>对系统运维人员或程序员，他们一般不关心用户输入错误，而关注编程错误或第三方错误，对于这些错误，需要报告尽量完整的细节，包括异常链、异常栈等，以便尽快定位和解决问题。</p><p>对于用户输入或编程错误，一般都是难以通过程序自动解决的，第三方错误则可能可以，甚至很多时候，程序都不应该假定第三方是可靠的，应该有容错机制。比如说，某个第三方服务连接不上(比如发短信)，可能的容错机制是，换另一个提供同样功能的第三方试试，还可能是，间隔一段时间进行重试，在多次失败之后再报告错误。</p><h3 id="异常处理的一般逻辑"><a href="#异常处理的一般逻辑" class="headerlink" title="异常处理的一般逻辑"></a><strong>异常处理的一般逻辑</strong></h3><p>如果自己知道怎么处理异常，就进行处理，如果可以通过程序自动解决，就自动解决，如果异常可以被自己解决，就不需要再向上报告。</p><p>如果自己不能完全解决，就应该向上报告。如果自己有额外信息可以提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常。</p><p>总有一层代码需要为异常负责，可能是知道如何处理该异常的代码，可能是面对用户的代码，也可能是主程序。如果异常不能自动解决，对于用户，应该根据异常信息提供用户能理解和对用户有帮助的信息，对运维和程序员，则应该输出详细的异常链和异常栈到日志。</p><p>这个逻辑与在公司中处理问题的逻辑是类似的，每个级别都有自己应该解决的问题，自己能处理的自己处理，不能处理的就应该报告上级，把下级告诉他的，和他自己知道的，一并告诉上级，最终，公司老板必须要为所有问题负责。每个级别既不应该掩盖问题，也不应该逃避责任</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础</title>
      <link href="/2022/0408undefined.html"/>
      <url>/2022/0408undefined.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql基础"><a href="#Mysql基础" class="headerlink" title="Mysql基础"></a>Mysql基础</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>数据库分为关系型数据库和非关系型数据库（重点学习redis）</p><p>MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p><p>DB : DataBase 数据库    DBMS  :  数据库管理系统    SQL ： 一种语言<br>然而DBMS负责执行SQL语句同时来操作DB当中的数据</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>DQL  （数据查询）查询语句  凡是select语句都是DQL<br>DML  （数据操作）insert  delete update 对表的中的数据进行增加删改<br>DDL  （数据定义）create drop alter 对表的结构进行增删改<br>TCL   （事务控制）commit 提交事务 roolllback 回滚事务<br>DCL （数据控制）  grant授权  revoke撤销权限等</p><h2 id="数据库的使用"><a href="#数据库的使用" class="headerlink" title="数据库的使用"></a>数据库的使用</h2><ol><li><p>数据库的<a href="https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&tn=baidu&wd=mysql%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&oq=Mysql%25E7%2599%25BE%25E5%25BA%25A6&rsv_pq=90b15b6400007c81&rsv_t=fe50btkb/o8H2zA0LfT7nf10BPalL86LKP6n6nqCHCF9sw0JuoKqH6nxri8&rqlang=cn&rsv_dl=ts_0&rsv_enter=1&rsv_btype=t&inputT=2466&rsv_sug3=14&rsv_sug1=11&rsv_sug7=100&rsv_sug2=1&prefixsug=Mysql&rsp=0&rsv_sug4=2890">安装</a></p></li><li><p>数据库的基本使用</p><p>查看数据 show databases;</p><p>创建数据库 create database huihui;</p><p>使用数据库 user huihui;  show tables;</p><p>删除数据库 drop database 数据库；</p></li><li><p>步骤</p><p>一、登录 打开dos命令窗口</p><p>​        mysql -uroot -p(密码是隐藏的)</p><p>二、查看有那些数据库  </p><p>​        show databases; </p><p>三、创建数据库</p><p>​        create database huihui;</p><p>四、使用数据库</p><p>​        show tables;</p><p>五、查看当前使用的数据</p><p>​        show tables;<br>六、创建一个表的结构<br>​        create table category(cid varchar(20) primary key,cname varchar(100));<br>​        </p><p>七、其他基本操作</p><p>​        查看表结构<br>​            desc category;<br>​        删除表的结构<br>​            drop tables;<br>​        删除库<br>​            drop detabase;<br>​        查看现在使用哪个数据库<br>​            select database();<br>​        修改表添加列<br>​            alter table 表名 add <code>列名</code> 类型（长度）约束；使用反引号<br>​        修改表的列名<br>​            alter table change 旧列名 新列名 类型（长度）；<br>​        修改表删除列<br>​            alter table 表名 drop 列名；<br>​        修改表的名字<br>​            rename table  表名 to 新表名；</p><pre><code>     八、插入表记录         insert into 表（字段1 ，字段2，字段3）values(值1 值2 值3)；         insert into 表 value（值1 ，值2 ，值3）     九、更新记录         update 表名 set 字段名 = 值 ， 字段名 = 值；    update  category set cname = &#39;家电&#39;；  将所有行cname改为家电    update category set  cname = &#39;水果&#39; where cid = &#39;coo1&#39; 将c001改为水果     十、删除表格         delete from category;</code></pre><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1></li></ol><p>表格前期的准备</p><p> create table product(<br> pid int primary key,<br> pname varchar(20),<br> price double,<br> category_id varchar(32)<br> );</p><p> insert into product(pid,pname,price,category_id) values(1,’联想’,5000,’c001’);<br> insert into product(pid,pname,price,category_id) values(2,’海尔’,3000,’c001’);<br> insert into product(pid,pname,price,category_id) values(3,’雷神’,5000,’c001’);<br> insert into product(pid,pname,price,category_id) values(4,’杰克琼斯’,800,’c002’);<br> insert into product(pid,pname,price,category_id) values(5,’真维斯’,200,’c002’);<br> insert into product(pid,pname,price,category_id) values(6,’花花公子’,440,’c002’);<br> insert into product(pid,pname,price,category_id) values(7,’劲霸’,2000,’c002’);<br> insert into product(pid,pname,price,category_id) values(8,’香奈儿’,800,’c003’);<br> insert into product(pid,pname,price,category_id) values(9,’相一本草’,200,’c003’);<br> insert into product(pid,pname,price,category_id) values(10,’面霸’,5,’c003’);<br> insert into product(pid,pname,price,category_id) values(11,’好想你枣’,56,’c004’);<br> insert into product(pid,pname,price,category_id) values(12,’香飘飘奶茶’,2,’c005’);<br> insert into product(pid,pname,price,category_id) values(13,’海澜之家’,1,’c002’);<br> insert into product(pid,pname,price,category_id) values(14,’辉辉’,5000,’c005’);</p><p> select pname,price from product;  查询价格和产品名称<br>+————+——-+</p><table><thead><tr><th>pname</th><th>price</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>+————+——-+</td><td></td></tr><tr><td>联想</td><td>5000</td></tr><tr><td>—-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>海尔</td><td>3000</td></tr><tr><td>—-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>雷神</td><td>5000</td></tr><tr><td>—-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>杰克琼斯</td><td>800</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>真维斯</td><td>200</td></tr><tr><td>——</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>花花公子</td><td>440</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>劲霸</td><td>2000</td></tr><tr><td>—-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>香奈儿</td><td>800</td></tr><tr><td>——</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>相一本草</td><td>200</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>面霸</td><td>5</td></tr><tr><td>—-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>好想你枣</td><td>56</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>香飘飘奶茶</td><td>2</td></tr><tr><td>———-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>海澜之家</td><td>1</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>辉辉</td><td>5000</td></tr><tr><td>—-</td><td>—-</td></tr><tr><td></td><td></td></tr><tr><td>+————+——-+</td><td></td></tr></tbody></table><p>select pname from product as p;  给表起别名 </p><p>select pname as 商品名 from product as p; 给列起别名</p><p>select pname as pn from product;  </p><p>select distinct price from product;  取重复</p><p>select pname,price+10 from product;  查询结果是表达式  将所用商品的价格+10进行显示</p><h2 id="分组查询-分页查询"><a href="#分组查询-分页查询" class="headerlink" title="分组查询  分页查询"></a>分组查询  分页查询</h2><p>删除语句  加条件<br>delect from product where pid &gt; 13; </p><p>分组查询</p><p>统计各类商品的个数<br>select category_id,count(*) from product group by category_id;</p><p>sql语句执行顺序</p><p>from &gt; where &gt; group by &gt; 聚合函数 &gt; having &gt; select &gt; order by &gt; limit </p><p>分组以后  select 的后面只能跟分组字段和聚合函数  </p><p>  select category_id,count(<em>) from product group by category_id having count(</em>) &gt;1;</p><p>  having 是在分组后对数据进行过滤 where是在分组前对数据进行过滤 </p><p>  分页查询:<br>  select from limit M,N;<br>M 是下标 下标从0开始  N 是显示的条数 limit M,N;<br>每页显示多少条记录每页显示5条<br>第一页  limit 0,5</p><p>insert into select  语句从一个表中复制数据 然后把数据插入到另一个表中；</p><p>insert into product2 select pid,pname,price from product where category_id = ‘c001’;</p><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>1支持如下运算</p><p><img src="https://img-blog.csdn.net/20180318220938450?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTIzMjUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lazyload placeholder" data-srcset="https://img-blog.csdn.net/20180318220938450?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTIzMjUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>select * from product where pname = ‘花花公子’;  商品查询</p><p> select * from product where price = 800;  </p><p> select * from product where price != 800; 价格不等于800</p><p> select * from product where price &lt;&gt; 800; 价格不等于800</p><p> select * from product where price not(price = 800); 价格不等于800</p><p> select * from product where pname like ‘花%’;   查询以 花 开头的商品</p><p> select * from product where pname like ‘%花%’;      查询所有含 花 的商品</p><p> select * from product where pname like ‘_想%’;  查询第二个字为想的商品</p><p> select * from product where category_id is null;</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p> select * from 表名 order by 排序字段 asc  默认是升序 </p><p> select *from product order by price asc; 升序</p><p> select *from product order by price desc; 降序</p><h2 id="表与表的关系"><a href="#表与表的关系" class="headerlink" title="表与表的关系"></a>表与表的关系</h2><h4 id="表与表的关系-1"><a href="#表与表的关系-1" class="headerlink" title="表与表的关系"></a>表与表的关系</h4><p>   一对一的关系</p><p>   一对多的关系</p><p>   多对多的关系</p><p>主键列 控制 外键列</p><p>alter table product  修改表<br>add constraint product_fk   添加<br>foreign key(category_id) references category(cid);            </p><h4 id="内连接查询-（两张表的交集）"><a href="#内连接查询-（两张表的交集）" class="headerlink" title="内连接查询  （两张表的交集）"></a>内连接查询  （两张表的交集）</h4><p>  1 隐藏式内连接查询   select * from A, B where 条件<br>  2 查询哪个分类下面有那些商品  </p><p>  select * from category a,products b where a,cid = b.category_id;<br>  select a,cname,b pname from category1 a,product1 b where a,cid = b.category_id;<br>显示连接  select * from A inner join B on 条件<br>select * from category a inner product1 b on a.cid = b.category_id;</p><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>查询 （关键字 outer join outer join B on 条件<br>    外连接 left outer join<br>      select  * from A left outer join B on 条件<br>    右连接 right outer join<br>      select * from A right outer join B on 条件</p><blockquote><p>select * from category1 a left outer join product b on a.cid = b.category_id;</p></blockquote><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><p>子查询1<br>其实就是 select 的嵌套 select * from (select * from (select * from))<br>    select * from<br>        product1 p<br>    where<br>        p.category_id = (select cid category1 where cname =’化妆品’);</p><p>让商品表里查询价格  等于  最高价格</p><p>mysql&gt; select * from product1 where price = (select max(price) from producr1);</p><p>字查询可以 作为一个临时表<br>se<br>    select* from product1 p,</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>select abs (-8) – 绝对值<br>select ceiling(9.4) –向上去整<br>select floor(9.4)  –向下取整数<br>select rand()  –返回一个0 ~ 1 直接的随机数<br>select sign(10)  – 判断一个数的符号  负数返回—1  正数返回1</p><p>  字符串函数<br> select char_length(‘即使再小的帆也能远航’)  字符串长度<br> select concat (‘wo’,’ai’,’nimen’) –拼接字符串</p><h2 id="开窗函数"><a href="#开窗函数" class="headerlink" title="开窗函数"></a>开窗函数</h2><p>​    用来直接排序等等</p><p>create table employee1 (empid int,ename varchar(20),deptid int,salary decimal(10,2));<br>insert into employee1 values(1,’刘备’,10,5500.00);<br>insert into employee1 values(2,’赵云’,10,4500.00);<br>insert into employee1 values(3,’张飞’,10,4500.00);<br>insert into employee1 values(4,’关羽’,10,3500.00);<br>insert into employee1 values(5,’曹操’,10,6500.00);<br>insert into employee1 values(6,’许褚’,10,5600.00);<br>insert into employee1 values(7,’张辽’,10,5400.00);<br>insert into employee1 values(8,’徐晃’,10,4500.00);</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>原子性<br> 要么都成功 要么都失败<br>一致性<br> 事务前后的数据都保持一致<br>持久性<br>  事务一旦提交   表示事务结束后的数据不随着外界原因导致数据丢失<br>隔离性<br>  事务的隔离是多个用户并发访问数据库时 数据库为每一个用户的事务 不被其他事务所干扰，<br>  多个并发的事务之间要相互隔离</p><p>  –mysql 是默认开启事务自动提交的<br>  set autocommit = 0 关闭<br>  set autocommit = 1 开启</p><p>–手动处理事务<br>set autocommit = 0 – 关闭自动提交</p><p>–事务开启<br>start transaction – 标记一个事务的开始 ， 从这个之后的sql都在同一个事务内</p><p>insert xx<br>insert xx</p><p>–提交 持久话<br>commit<br>–回滚 回到原来的样子<br>rollback<br>–事务结束<br>set autocommit = 1 –开启自动提交</p><p>–了解<br>sevepoint 保存点名  设置一个事务的保存点<br>pollback to savepoint 保存点名  回滚到保存点<br>release savepoint 保存点名 –</p><h2 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h2><p>权限管理    用户管理</p><p>MySQL 数据库备份的方式</p><p>​    1.直接拷贝物理文件</p><p>​    2.直接设置数据库的设计<br>​    </p><pre><code>良好的数据库  节省内存空间  保证数据库的完整行  方便我们开发系统设计数据库步骤  收集信息 分析需求   用户表（用户登录注销 用户的个人信息  写博客 创建分类   分类表   文章表   友链表   自定义表    标识体</code></pre><p>三大范式<br>    信息重复</p><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，<br>    就说明该数据库表满足了第一范式。</p><p>第二范式(确保表中的每列都和主键相关)<br>  第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关 ，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p> 第三范式(确保每列都和主键列直接相关,而不是间接相关)<br>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。<br>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立<br>相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。<br>如下面这两个表所示的设计就是一个满足第三范式的数据库表。</p><p> 规范性和性能的问题<br>      关联的表不得超过三张表<br>      考虑商业化的需求和目标 （成本，用户体验） 数据库的性能更加重要<br>      在规范性能的问题的时候 需要适当的考虑一下规范性<br>      故意给某些表增加一下字段 （从多表查询标为单表查询）</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引的分类<br>    1  树索引<br>    2  哈希索引</p><p>创建索引<br>    create i ndex price_indexN-<br>    amei ON mytable(username([length]);</p><pre><code>create index price_index on product1(price);</code></pre><p>方式2  修改表的结构<br>    alter table product1 sdd index pname_index(pname);<br>方式3  创建表的时候指定<br>    create table myable(<br>     id int not null,<br>     username varchar(16) notnull,<br>     index username_index(username);</p><p>查看索引<br>    show index from product1;<br>查看表的索引<br>    select * from mysql.inndb_index_stats<code>a where a,</code>database_name `=’数据库’;</p><p>查看某一表的索引<br>        select * from mysql.inndb_index_stats<code>a where a,</code>database_name <code>=&#39;数据库&#39;and     a.table_name like&#39;%表名%&#39;;     select * from mysql.inndb_index_stats</code>a where a,<code>database_name </code>=’bigdata_db’and a.table_name like’%product1%’;</p><p>删除索引<br>    drop index [名字] on product1;</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组讲解</title>
      <link href="/2022/0403undefined.html"/>
      <url>/2022/0403undefined.html</url>
      
        <content type="html"><![CDATA[<h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><p>​    想必学过数据结构的同学都知道数组了，接下来就带大家了解一下。</p><h3 id="1-数组的存储方式"><a href="#1-数组的存储方式" class="headerlink" title="1 数组的存储方式"></a>1 数组的存储方式</h3><p>​    数组是通过下标索引获取的方式到下标下对应的数据，数组是存放在内存空间的，每一个数都对应的一个相对地址。我在这里不过多的赘述了，具体的大家去查资料。</p><h3 id="2-注意两点"><a href="#2-注意两点" class="headerlink" title="2 注意两点"></a>2 注意两点</h3><p>   · 数组下标都是从0开始的<br>   · 数组内存空间的地址都是连续的</p><p>首先从leetcode的第一题开始说起两数之和，这一题有多种解法，我从暴力破解和HashMap两种开始讲解。</p><p><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></p><p>第一种双重for循环也为暴力破解</p><p>​    如果使用暴力破解不会 大家就想想学的<a href="https://www.baidu.com/s?ie=UTF-8&wd=%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95">冒泡算法</a>  是不是使用双指针先确定一个依次循环然后遍历并且相加得到值进行比较。</p><p>注意返回的格式 ” new int[] {i,j} “ </p><p>第二中方法 哈希表</p><p>​    如果对哈希表了解不是很全面，到<a href="https://turingplanet.org/2020/03/08/%e5%93%88%e5%b8%8c%e8%a1%a8-hash-table%e3%80%8c%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%92%8c%e7%ae%97%e6%b3%956%e3%80%8d/#ha_xi_biao_de_gai_nian">哈希表</a>来了解，总之算法不是一天修成，大家持之以恒终有一天会成为算法大佬（我也是菜鸟）</p><p>整个for循环我相信大家可以理解 但是对于 <a href="https://www.runoob.com/java/java-hashmap-containskey.html">“ map.containsKey(target - nums[i]) ”</a> 肯定理解不是很到位，可以到菜鸟教程了解，也可以点击我给的超链接， 注意返回的格式 ” new int[] {i,j} “ 。</p><pre class="line-numbers language-none"><code class="language-none">hashmap.containsKey(Object key)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 如果 hashMap 中存在指定的 key 对应的映射关系返回 true，否则返回 false。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int[] twoSum(int[] nums, int target) &#123;            第一种解法         int let &#x3D; nums.length;         for(int i &#x3D; 0;i &lt; let;i++)&#123;             for(int j &#x3D; i + 1; j &lt; let; ++j)&#123;                 if(nums[i]+nums[j] &#x3D;&#x3D; target)&#123;                     return new int[] &#123;i,j&#125;;                     &#x2F;&#x2F;注意返回的形式 我第一踩的坑就是不会返回 new的数组。                 &#125;             &#125;         &#125;第二种解法        Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();        for(int i &#x3D; 0;i&lt;nums.length;i++)&#123;             &#x2F;&#x2F; 如果 hashMap 中存在指定的 key 对应的映射关系返回 true，否则返回 false。            if(map.containsKey(target - nums[i]))&#123;                return new int[]&#123;map.get(target - nums[i]),i&#125;;            &#125;            map.put(nums[i],i);        &#125;                return new int[2];    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>忠告大家：</p><p>​    · 练习算法千万不能直接复制粘贴，哪怕不会做没有思路，也千万不用复制粘贴。实在不跟着思路抄一遍，只会有益无害。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/0330undefined.html"/>
      <url>/2022/0330undefined.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>本站说明</title>
      <link href="/2022/0301undefined.html"/>
      <url>/2022/0301undefined.html</url>
      
        <content type="html"><![CDATA[<pre><code>本站只用于学习参考，如有错误请即使指出，大家一起进步一起成长。</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
